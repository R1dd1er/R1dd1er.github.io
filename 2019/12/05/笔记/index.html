<!DOCTYPE html>



  


<html class="theme-next muse use-motion" lang="zh-Hans">
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform">
<meta http-equiv="Cache-Control" content="no-siteapp">
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css">







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css">

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="Hexo, NexT">










<meta name="description" content="TCP + UDP并发服务器+循环服务器TCP并发服务器基本流程创建侦听套接口，等待客户机的请求接受到一个客户机请求时，创建一个子进程子进程进行数据处理父进程继续等待新的客户机请求 UDP并发服务器基本流程创建并绑定一个套接口接收到请求数据时，创建一个子进程子进程进行数据处理父进程继续接收请求数据 复杂的UDP服务器基本流程创建并绑定一个套接口接收到请求数据时，创建一个子进程子进程创建新套接口，进">
<meta property="og:type" content="article">
<meta property="og:title" content="R1dd1er&#39;s blogs">
<meta property="og:url" content="http://yoursite.com/2019/12/05/笔记/index.html">
<meta property="og:site_name" content="R1dd1er&#39;s blogs">
<meta property="og:description" content="TCP + UDP并发服务器+循环服务器TCP并发服务器基本流程创建侦听套接口，等待客户机的请求接受到一个客户机请求时，创建一个子进程子进程进行数据处理父进程继续等待新的客户机请求 UDP并发服务器基本流程创建并绑定一个套接口接收到请求数据时，创建一个子进程子进程进行数据处理父进程继续接收请求数据 复杂的UDP服务器基本流程创建并绑定一个套接口接收到请求数据时，创建一个子进程子进程创建新套接口，进">
<meta property="og:locale" content="zh-Hans">
<meta property="og:image" content="http://ww1.sinaimg.cn/large/00643K3ogy1g9kyxf6tevj309v0kx442.jpg">
<meta property="og:image" content="http://ww1.sinaimg.cn/large/00643K3ogy1g9kysw11jcj30iy0hk7aj.jpg">
<meta property="og:updated_time" content="2019-12-04T16:12:08.565Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="R1dd1er&#39;s blogs">
<meta name="twitter:description" content="TCP + UDP并发服务器+循环服务器TCP并发服务器基本流程创建侦听套接口，等待客户机的请求接受到一个客户机请求时，创建一个子进程子进程进行数据处理父进程继续等待新的客户机请求 UDP并发服务器基本流程创建并绑定一个套接口接收到请求数据时，创建一个子进程子进程进行数据处理父进程继续接收请求数据 复杂的UDP服务器基本流程创建并绑定一个套接口接收到请求数据时，创建一个子进程子进程创建新套接口，进">
<meta name="twitter:image" content="http://ww1.sinaimg.cn/large/00643K3ogy1g9kyxf6tevj309v0kx442.jpg">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Muse',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: 'R1dd1er'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/2019/12/05/笔记/">





  <title> | R1dd1er's blogs</title>
  








</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">R1dd1er's blogs</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle">积跬步，至千里</p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br>
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br>
            
            关于
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br>
            
            归档
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/12/05/笔记/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="R1dd1er">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/touxiang.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="R1dd1er's blogs">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline"></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-12-05T00:13:55+08:00">
                2019-12-05
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          
            <span class="post-meta-divider">|</span>
            <span class="page-pv"><i class="fa fa-file-o"></i>
            <span class="busuanzi-value" id="busuanzi_value_page_pv"></span>
            </span>
          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <h2 id="TCP-UDP并发服务器-循环服务器"><a href="#TCP-UDP并发服务器-循环服务器" class="headerlink" title="TCP + UDP并发服务器+循环服务器"></a>TCP + UDP并发服务器+循环服务器</h2><h3 id="TCP并发服务器"><a href="#TCP并发服务器" class="headerlink" title="TCP并发服务器"></a>TCP并发服务器</h3><h4 id="基本流程"><a href="#基本流程" class="headerlink" title="基本流程"></a>基本流程</h4><p>创建侦听套接口，等待客户机的请求<br>接受到一个客户机请求时，创建一个子进程<br>子进程进行数据处理<br>父进程继续等待新的客户机请求</p>
<h3 id="UDP并发服务器"><a href="#UDP并发服务器" class="headerlink" title="UDP并发服务器"></a>UDP并发服务器</h3><h5 id="基本流程-1"><a href="#基本流程-1" class="headerlink" title="基本流程"></a>基本流程</h5><p>创建并绑定一个套接口<br>接收到请求数据时，创建一个子进程<br>子进程进行数据处理<br>父进程继续接收请求数据</p>
<h4 id="复杂的UDP服务器"><a href="#复杂的UDP服务器" class="headerlink" title="复杂的UDP服务器"></a>复杂的UDP服务器</h4><h5 id="基本流程-2"><a href="#基本流程-2" class="headerlink" title="基本流程"></a>基本流程</h5><p>创建并绑定一个套接口<br>接收到请求数据时，创建一个子进程<br>子进程创建新套接口，进行数据处理<br>父进程继续接收请求数据</p>
<p>案例:TFTP</p>
<h3 id="TCP循环服务器"><a href="#TCP循环服务器" class="headerlink" title="TCP循环服务器"></a>TCP循环服务器</h3><p>TCP循环服务器接收一个客户端的连接，然后进行处理，直到完成这个客户机的所有请求后，断开连接。<br>TCP循环服务器一次只能处理一个客户端的请求，只有在这个客户的所有请求都满足后，服务器才能继续后面的请求。<br>若一个客户端占住服务器不放，其他客户机都不能工作</p>
<p>TCP服务器很少用循环服务器模式<br>数据处理所需时间短<br>服务器只能为单一用户提供服务时，此时应设置超时控制</p>
<h4 id="TCP循环服务器的缺陷"><a href="#TCP循环服务器的缺陷" class="headerlink" title="TCP循环服务器的缺陷"></a>TCP循环服务器的缺陷</h4><p>客户要独占服务器<br>服务器一次只能处理一个客户端请求<br>必须处理完客户的所有请求， 才释放服务器</p>
<h3 id="UDP循环服务器"><a href="#UDP循环服务器" class="headerlink" title="UDP循环服务器"></a>UDP循环服务器</h3><p>基于UDP的通信是面向无连接的，没有一个客户机可以独占服务器<br>只要处理过程不是死循环，服务器总能满足每个客户机的请求</p>
<h3 id="循环服务器案例与流程分析"><a href="#循环服务器案例与流程分析" class="headerlink" title="循环服务器案例与流程分析"></a>循环服务器案例与流程分析</h3><p><img src="http://ww1.sinaimg.cn/large/00643K3ogy1g9kyxf6tevj309v0kx442.jpg" alt="1334023-20180916114628433-2025110502.png"></p>
<p> 调用accept函数后，紧接着调用I/O相关的read、write函数，然后调用close函数。这并非针对服务器端套接字，而是针对accept函数调用时所创建的套接字。 </p>
<p>例如：网络控制的可移动机械手<br>服务器程序运行在机械手的移动平台上<br>用户通过网络远程操控机械手完成搬运物体的工作<br>机械手为独占资源<br>采用UDP协议实现比较麻烦<br>UDP不可靠，指令无法顺序执行<br>多用户指令相互干扰<br>可在应用层协议中加上时序控制与独占标识，增大编程难度<br>采用TCP循环模式，并对阻塞函数添加超时控制</p>
<h3 id="并发服务器-多路复用I-O"><a href="#并发服务器-多路复用I-O" class="headerlink" title="并发服务器:多路复用I/O"></a>并发服务器:多路复用I/O</h3><p>调用select函数实现对多个客户机请求的多路复用<br>优点：只需一进程处理所有客户机的请求，不需要创建子进程<br>缺点：服务器必须依次处理所有客户机的请求；会导致客户等待很久<br>适合具有请求数据多，但请求内容少的服务类型</p>
<h4 id="多路复用I-O处理过程"><a href="#多路复用I-O处理过程" class="headerlink" title="多路复用I/O处理过程"></a>多路复用I/O处理过程</h4><p>设置读和写描述符表，读描述符集包括侦听套接口描述符<br>调用函数select测试描述符是否就绪<br>当侦听套接口就绪后，接收新的连接<br>其他就绪套接口依次处理读写操作<br>返回1</p>
<h3 id="TCP与UDP的对比"><a href="#TCP与UDP的对比" class="headerlink" title="TCP与UDP的对比"></a>TCP与UDP的对比</h3><h4 id="TCP"><a href="#TCP" class="headerlink" title="TCP"></a>TCP</h4><p>可靠的面向连接传输层协议<br>无数据边界，面向字节流的数据提交<br>数据编号、确认、排序、估计重传时间与重传、流量控制<br>全双工</p>
<p>窗口式流量控制</p>
<p>慢启动和拥塞避免</p>
<h5 id="滑动窗口协议"><a href="#滑动窗口协议" class="headerlink" title="滑动窗口协议"></a>滑动窗口协议</h5><p> 滑动窗口协议，接收数据的套接字每次会告诉发送数据的套接字可传递的最大字节数，于是发送数据的套接字收到这个数字后传递等长度大小的数据，待接收数据的套接字发现缓冲中腾出更多位置，会告诉发送数据的套接字，接收更多的数据。因此，TCP不会因为缓冲满了而丢失数据 </p>
<h4 id="UDP"><a href="#UDP" class="headerlink" title="UDP"></a>UDP</h4><p>简单的无连接传输层协议<br>带数据边界的基于数据包的提交<br>尽最大努力提交数据分组</p>
<p>全双工</p>
<p>支持广播与多播</p>
<p>没有连接建立与拆除</p>
<h5 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h5><p>对于广播或多播的应用程序必须使用UDP。</p>
<p>海量数据传输通常不适用UDP(例外:TFTP使用UDP传输海量数据 ,NFS网络文件服务器，采用UDP传输海量数据 )</p>
<p>增加一些必要的错误控制到应用系统。</p>
<p>对于要求可靠递送的多播应用系统（多播文件传输），需要衡量使用多播的性能收益。</p>
<h2 id="基础套接口函数的用法与注意事项-例如socket-bind-listen-accept-IO-shut-down-与close的关系-connect"><a href="#基础套接口函数的用法与注意事项-例如socket-bind-listen-accept-IO-shut-down-与close的关系-connect" class="headerlink" title="基础套接口函数的用法与注意事项 例如socket bind listen accept     IO    shut down 与close的关系   connect"></a>基础套接口函数的用法与注意事项 例如socket bind listen accept     IO    shut down 与close的关系   connect</h2><h3 id="shut-down-与close的区别"><a href="#shut-down-与close的区别" class="headerlink" title="shut down 与close的区别"></a>shut down 与close的区别</h3><p> shutdown函数就是用于半关闭流的函数  </p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">shutdown</span><span class="params">(<span class="keyword">int</span> sock, <span class="keyword">int</span> howto)</span></span>;<span class="comment">//成功时返回0，失败时返回-1</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">sock：需要断开的套接字文件描述符</span><br><span class="line">howto：传递断开方式信息</span><br></pre></td></tr></table></figure>
<p>调用上述函数时，第二个参数决定断开连接的方式，其可能值如下：<br>    SHUT_RD：断开输入流<br>    SHUT_WR：断开输出流<br>    SHUT_RDWR：同时断开I/O流</p>
<p>若向shutdown的第二个参数传递SHUT_RD，则断开输入流，套接字无法接收数据。即使输入缓冲收到数据也会抹去，而且无法调用输入相关函数；若向shutdown函数的第二个参数传递SHUT_WR，则中断输出流，也就无法传输数据，但如果输出缓冲还留有未传输的数据，则将传至目标主机。最后，若传入SHUT_RDWR，则同时断开I/O流，这相当于分两次调用shutdown，其中一次以SHUT_RD为参数，另一次以SHUT_WR为参数 </p>
<p>shutdown操作连接通道,其他进程不能再使用已被关闭的通道</p>
<p>shutdown终止网络连接中所有信息的发送与接收,不管引用计数器为和值</p>
<p>close操作描述符,其他进程可以使用该socket描述符</p>
<p>close关闭套接字仅当引用计数器值为零</p>
<h3 id="bind-分配套接字地址"><a href="#bind-分配套接字地址" class="headerlink" title="bind(分配套接字地址)"></a>bind(分配套接字地址)</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">bind</span><span class="params">(<span class="keyword">int</span> sockfd, struct sockaddr *myaddr, <span class="keyword">socklen_t</span> addrlen)</span></span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">sockfd：要分配地址信息（IP地址和端口号）的套接字文件描述符</span><br><span class="line">myaddr：存有地址信息的结构体变量地址值</span><br><span class="line">addrlen：第二个结构体变量的长度</span><br></pre></td></tr></table></figure>
<h3 id="listen-等待连接请求状态"><a href="#listen-等待连接请求状态" class="headerlink" title="listen(等待连接请求状态)"></a>listen(等待连接请求状态)</h3><p> 只有调用了listen函数，服务端套接字才能进入可接收连接的状态，换言之，这时，客户端才能调用connect函数（若提前调用则会发生错误） </p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">listen</span><span class="params">(<span class="keyword">int</span> sockfd, <span class="keyword">int</span> backlog)</span></span>;<span class="comment">//成功时返回0，失败时返回-1</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">sock：希望进入等待连接请求状态的套接字文件描述符，传递的描述符套接字参数成为服务端套接字（监听套接字）</span><br><span class="line">backlog：连接请求等待队列（Queue）的长度，若为<span class="number">5</span>，则队列长度为<span class="number">5</span>，表示最多使<span class="number">5</span>个连接请求进入队列</span><br></pre></td></tr></table></figure>
<p> 等待连接请求状态的含义和连接请求等待队列。“服务器端处于等待连接请求状态”是指，客户端请求连接时，服务器端受理连接前一直处于等待状态，当有多个客户端一起发送连接请求时，服务器端套接字只能处理一个连接请求，而其他的连接请求，只能暂时放在请求队列，即listen函数的第二个参数 </p>
<h3 id="accept-允许连接"><a href="#accept-允许连接" class="headerlink" title="accept(允许连接)"></a>accept(允许连接)</h3><p> 调用listen函数后，若有新的连接请求，则应按序受理。受理请求意味着进入可接收数据的状态，这里进入这种状态的所需部件当然还是套接字，可能有人会想使用服务器端套接字，但服务器端套接字已经用于监听，如果将其用于与客户端交换数据，那么谁来监听客户端的连接请求呢？因此需要另外一个套接字，但没必要亲自创建，accept函数将自动创建套接字，并连接到发起请求的客户端 </p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">accept</span><span class="params">(<span class="keyword">int</span> sockfd, struct sockaddr *addr, <span class="keyword">socklen_t</span> *addrlen)</span></span>;<span class="comment">//成功时返回创建的套接字文件描述符，失败时返回-1</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">sock：服务器套接字的文件描述符</span><br><span class="line">addr：保存发起连接请求的客户端地址信息的变量地址值，调用函数后向传递来的地址变量参数填充客户端地址信息</span><br><span class="line">addrlen：第二个参数addr结构体的长度，但是存有长度的变量地址。函数调用完成后，该变量即被填入客户端地址长度</span><br></pre></td></tr></table></figure>
<p> accept函数受理连接请求等待队列中待处理的客户端连接请求，函数调用成功时，accept函数内部将产生用于数据I/O的套接字，并返回其文件描述符。需要强调的是，套接字是自动创建的，并自动与发起连接请求的客户端建立连接 </p>
<h4 id="基于UDP的数据I-O函数"><a href="#基于UDP的数据I-O函数" class="headerlink" title="基于UDP的数据I/O函数"></a><strong>基于UDP的数据I/O函数</strong></h4><p> 创建好TCP套接字后，传输数据时无需再添加地址信息，因为TCP套接字将保持与对方套接字的连接。换言之，TCP套接字知道目标地址信息。但UDP套接字不会保持连接状态（UDP套接字只有简单的邮筒功能），因此每次传输数据都要添加目标地址信息。这相当于寄信前在信件中填写地址，接下来介绍填写地址并传输数据时调用的UDP相关函数  </p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="keyword">ssize_t</span> sendto(<span class="keyword">int</span> sock, <span class="keyword">const</span> <span class="keyword">void</span> *buff, <span class="keyword">size_t</span> nbytes, <span class="keyword">int</span> flags, <span class="keyword">const</span> struct sockaddr *to, <span class="keyword">socklen_t</span> addrlen);<span class="comment">//成功时返回传输的字节数，失败时返回-1</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">sock：用于传输数据的UDP套接字文件描述符</span><br><span class="line">buff：保存待传输数据的缓冲地址值</span><br><span class="line">nbytes：待传输的数据长度，以字节为单位</span><br><span class="line">flags：可选项参数，若没有则传递<span class="number">0</span></span><br><span class="line">to：存有目标地址信息的sockaddr结构体变量的地址值</span><br><span class="line">addrlen：传递给参数to的地址值结构体变量长度</span><br></pre></td></tr></table></figure>
<p> 上述函数与之前的TCP输出函数最大的区别在于，此函数需要向它传递目标地址信息。接下来介绍接收UDP数据的函数，UDP数据的发送端并不固定，因此该函数定义为可接收发送端信息的形式，也就是将同时返回UDP数据包的发送端信息 </p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="keyword">ssize_t</span> recvfrom (<span class="keyword">int</span> sock, <span class="keyword">void</span> *buff, <span class="keyword">size_t</span> nbytes, <span class="keyword">int</span> flags, struct sockaddr * from, <span class="keyword">socklen_t</span> * addrlen);<span class="comment">//成功时返回接收的字节数，失败时返回-1</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">sock：用于接收数据的UDP套接字文件描述符</span><br><span class="line">buff：保存接收数据的缓冲地址值</span><br><span class="line">nbytes：可接收的最大字节数，故无法超过参数buff所指的缓冲大小</span><br><span class="line">flags：可选项参数，若没有则传递<span class="number">0</span></span><br><span class="line">from：存有发送端地址信息的sockaddr结构体变量的地址值</span><br><span class="line">addrlen：保存参数from的结构体变量长度的变量地址值</span><br></pre></td></tr></table></figure>
<h4 id="UDP的数据传输特性和调用connect函数"><a href="#UDP的数据传输特性和调用connect函数" class="headerlink" title="UDP的数据传输特性和调用connect函数"></a><strong>UDP的数据传输特性和调用connect函数</strong></h4><p>TCP数据传输中不存在边界，这表名数据传输过程中调用I/O函数的次数不具有任何意义。相反，UDP是具有数据边界协议的，传输中调用I/O函数的次数非常重要。因此，输入函数的调用次数应和输出函数的调用次数完全一致，这样才能保证接收全部已发送的数据。 </p>
<p>TCP套接字中需注册待传输数据的目标IP和端口号，而UDP中则无需注册。因此，通过sendto函数传输数据的过程大致可分为以下三个阶段：</p>
<ol>
<li>第一阶段：向UDP套接字注册目标IP和端口号</li>
<li>第二阶段：传输数据</li>
<li>第三阶段：传输UDP套接字中注册的目标地址信息</li>
</ol>
<p>每次调用sendto函数时重复上述过程，每次都变更目标地址，因此可以重复利用同一UDP套接字向不同目标传输数据。这种未注册目标地址信息的套接字称为未连接套接字，反之，注册了目标地址的套接字称为连接connected套接字。显然，UDP套接字默认属于未连接套接字。但是，要与同一主机进行长时间通信时，将UDP套接字变为已连接套接字会提高效率，上述三个阶段中，第一个阶段和第三个阶段将占用整个通信过程的1/3的时间，缩短这部分时间将大大提高性能</p>
<p> 创建已连接的UDP套接字很简单，只需针对UDP套接字调用connect函数  </p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">sock = socket(PF_INET, SOCK_DGRAM, <span class="number">0</span>);</span><br><span class="line"><span class="built_in">memset</span>(&amp;adr, <span class="number">0</span>, <span class="keyword">sizeof</span>(adr));</span><br><span class="line">adr.sin_family = AF_INET;</span><br><span class="line">adr.sin_addr.s_addr = .....;</span><br><span class="line">adr.sin_port = ....;</span><br><span class="line">connect(sock, (struct sockaddr *)&amp;adr, <span class="keyword">sizeof</span>(adr));</span><br></pre></td></tr></table></figure>
<p> 上述代码看似与TCP套接字创建过程一致，但socket函数的第二个参数是SOCK_DGRAM，也就是说，创建的的确是UDP套接字。当然，针对UDP套接字调用connect函数并不意味着要与对方的UDP套接字连接，这只是向UDP套接字注册目标IP和端口信息。之后就与TCP套接字一样，每次调用sendto函数只需传输数据，因为已经指定了收发对象，所以不仅可以使用sendto、recvfrom函数，还可以使用write、read函数进行通信 </p>
<h4 id="TCP基本流程"><a href="#TCP基本流程" class="headerlink" title="TCP基本流程"></a>TCP基本流程</h4><p><img src="http://ww1.sinaimg.cn/large/00643K3ogy1g9kysw11jcj30iy0hk7aj.jpg" alt="1334023-20180916113634061-1996039322.png"></p>
<p> 服务器端创建套接字后联系调用bind、listen函数进入等待状态，客户端通过调用connect函数发起连接请求，需要注意的是，客户端只能等到服务器端调用listen函数后才能调用connect函数。同时要清楚，客户端调用connect前，服务器端可能先调用了accept函数。当然，此时服务器端在调用accept函数时进入了阻塞状态，直到客户端调用connect函数为止 </p>
<h2 id="状态转换表-有些地方要填写-二倍的MSL-作用是什么"><a href="#状态转换表-有些地方要填写-二倍的MSL-作用是什么" class="headerlink" title="状态转换表 , 有些地方要填写 二倍的MSL  作用是什么"></a>状态转换表 , 有些地方要填写 二倍的MSL  作用是什么</h2><p>(TIME_WAIT状态(2MSL)的作用):</p>
<p>1.可靠的实现TCP全双工连接的终止(假设最终的ACK丢失)</p>
<p>2.允许老的重复分节在网络中消失 </p>
<p>允许老的重复分节在网络中的消逝</p>
<p>假设在12.106.32.254的端口1500和206.168.112.219的端口21之间有一个TCP连接。关闭这个连接后，某个时间又建立了相同的IP地址和端口之间的TCP连接。后一个连接称为前一个连接的化身。TCP必须防止老的重复分组在连接已终止后再现，从而误解成属于同一连接的新的化身。那么TIME_WAIT状态持续2MSL时间，足够允许分组或应答最多存活MSL秒即被丢弃。这样就保证了当成功建立一个TCP连接时，来自连接先前化身的老的重复分组都已经在网络中消逝了。</p>
<h2 id="TCP连接队列满了怎么办"><a href="#TCP连接队列满了怎么办" class="headerlink" title="TCP连接队列满了怎么办"></a>TCP连接队列满了怎么办</h2><p>TCP将忽略客户传来的SYN，不发送 RST，客户端将重发SYN</p>
<h2 id="listen监听列表满了怎么办"><a href="#listen监听列表满了怎么办" class="headerlink" title="listen监听列表满了怎么办"></a>listen监听列表满了怎么办</h2><h2 id="UDP-connect与TCP的connect的的区别"><a href="#UDP-connect与TCP的connect的的区别" class="headerlink" title="UDP connect与TCP的connect的的区别"></a>UDP connect与TCP的connect的的区别</h2><p>UDP与TCP位于同一层(传输层)，都建立在IP协议的基础上</p>
<p>UDP非面向连接</p>
<p>TCP它面向连接,只是可靠投递或故障的可靠通知</p>
<p>TCP不支持多点播送或广播</p>
<h2 id="多播与广播的特点-优点-缺点-例子-功能-分别用于什么场景-需看得懂代码的作用"><a href="#多播与广播的特点-优点-缺点-例子-功能-分别用于什么场景-需看得懂代码的作用" class="headerlink" title="多播与广播的特点 优点  缺点 例子 功能 分别用于什么场景 需看得懂代码的作用"></a>多播与广播的特点 优点  缺点 例子 功能 分别用于什么场景 需看得懂代码的作用</h2><p>四种寻址方式:单播（unicasting）,任播（anycasting）,广播（broadcasting）,多播（multicasting）</p>
<h3 id="广播"><a href="#广播" class="headerlink" title="广播"></a>广播</h3><p>局限于局域网内使用</p>
<h4 id="广播优点"><a href="#广播优点" class="headerlink" title="广播优点"></a>广播优点</h4><p>向网络中所有主机进行发送信息</p>
<p>资源发现</p>
<p>节约带宽</p>
<h4 id="广播缺点"><a href="#广播缺点" class="headerlink" title="广播缺点"></a>广播缺点</h4><p>局限于局域网内使用</p>
<p>无法针对每个客户的要求和时间及时提供个性化服务 </p>
<p>广播存在的问题： </p>
<p>子网上未参加相应广播应用的所有主机必需沿协议栈一路向上完整地处理收取的UDP广播数据报，直到数据报到达UDP层时被丢弃。<br>子网所有非IPv4的主机（如IPX的主机）也要在数据链路层接收完整的帧，再丢弃它。<br>若是较高速率产生IP数据报的应用（音视频），这些非必要的处理会影响子网上其他主机的工作<br>UDP层丢弃时，该主机不产生ICMP端口不可达报文<br>因为可能产生广播风暴<br>子网上大量主机几乎同时产生响应，导致网络短时间内不可用</p>
<h4 id="广播应用"><a href="#广播应用" class="headerlink" title="广播应用"></a>广播应用</h4><p>网络时间协议,路由守护进程,ARP,DHCP,NTP</p>
<h3 id="多播"><a href="#多播" class="headerlink" title="多播"></a>多播</h3><p>局域网，跨广域网都可使用</p>
<p>多播数据报只应该由对它感兴趣的网络接口接收</p>
<h4 id="多播优点"><a href="#多播优点" class="headerlink" title="多播优点"></a>多播优点</h4><p>局域网，跨广域网都可使用</p>
<p>降低了不参与多播应用系统的其他主机上的负荷</p>
<p> 即使只发送一次数据，但该组内的所有客户端都会接收数据 </p>
<h4 id="多播缺点"><a href="#多播缺点" class="headerlink" title="多播缺点"></a>多播缺点</h4><p> 与单播协议相比没有纠错机制，发生丢包错包后难以弥补，但可以通过一定的容错机制和QOS加以弥补。 </p>
<h4 id="多播应用"><a href="#多播应用" class="headerlink" title="多播应用"></a>多播应用</h4><h2 id="带外数据-理论-编程实现"><a href="#带外数据-理论-编程实现" class="headerlink" title="带外数据 理论 + 编程实现"></a>带外数据 理论 + 编程实现</h2><h3 id="几种方式发送带外数据"><a href="#几种方式发送带外数据" class="headerlink" title="几种方式发送带外数据"></a>几种方式发送带外数据</h3><p>TCP紧急模式的一个重要特点：TCP头部指出发送端已经进入紧急模式（伴随紧急偏移的标志已经设置），但是由紧急指针所指的实际数据字节却不一定随同送出。若发送端TCP因流量控制而暂停发送数据：         </p>
<p>接收端的套接口接收缓冲区已满，导致其TCP向发送端TCP通告了一个值为0的窗口。</p>
<p>紧急通知照样不伴随任何数据地发送：       </p>
<p>即便数据的流动会因为TCP的流量控制而停止，紧急通知却总是无障碍地发送到对端TCP 。</p>
<h2 id="主要-第一章到第七章"><a href="#主要-第一章到第七章" class="headerlink" title="主要 第一章到第七章"></a>主要 第一章到第七章</h2><h2 id="第九章多线程第十章windows编程基本没有"><a href="#第九章多线程第十章windows编程基本没有" class="headerlink" title="第九章多线程第十章windows编程基本没有"></a>第九章多线程第十章windows编程基本没有</h2><h2 id="名词解释4题-20分"><a href="#名词解释4题-20分" class="headerlink" title="名词解释4题  20分"></a>名词解释4题  20分</h2><h2 id="选择题-10多选-10单选-30分"><a href="#选择题-10多选-10单选-30分" class="headerlink" title="选择题 10多选  10单选  30分"></a>选择题 10多选  10单选  30分</h2><h2 id="问答题4题-20分"><a href="#问答题4题-20分" class="headerlink" title="问答题4题   20分"></a>问答题4题   20分</h2><h2 id="程序阅读题-1题"><a href="#程序阅读题-1题" class="headerlink" title="程序阅读题 1题"></a>程序阅读题 1题</h2><h2 id="编程题-基本框架-大部分函数原型都在"><a href="#编程题-基本框架-大部分函数原型都在" class="headerlink" title="编程题  基本框架  大部分函数原型都在"></a>编程题  基本框架  大部分函数原型都在</h2><h2 id="动态分区"><a href="#动态分区" class="headerlink" title="动态分区"></a>动态分区</h2><p>数组为载体</p>
<h3 id="主要步骤"><a href="#主要步骤" class="headerlink" title="主要步骤"></a>主要步骤</h3><p>1.创建一定大小的数组,全部初始化为0,选择数组分段为已分配分区,置为1</p>
<p>2.输入插入作业的大小,其次选择使用哪种算法,然后进行插入,并显示出结果</p>

      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2019/11/16/浅谈DNS重绑定漏洞/" rel="next" title="浅谈DNS重绑定漏洞">
                <i class="fa fa-chevron-left"></i> 浅谈DNS重绑定漏洞
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          

  



        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            站点概览
          </li>
        </ul>
      

      <section class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image" src="/images/touxiang.png" alt="R1dd1er">
            
              <p class="site-author-name" itemprop="name">R1dd1er</p>
              <p class="site-description motion-element" itemprop="description"></p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">14</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            

            

          </nav>

          

          

          
          

          
          

          

        </div>
      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#TCP-UDP并发服务器-循环服务器"><span class="nav-number">1.</span> <span class="nav-text">TCP + UDP并发服务器+循环服务器</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#TCP并发服务器"><span class="nav-number">1.1.</span> <span class="nav-text">TCP并发服务器</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#基本流程"><span class="nav-number">1.1.1.</span> <span class="nav-text">基本流程</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#UDP并发服务器"><span class="nav-number">1.2.</span> <span class="nav-text">UDP并发服务器</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#基本流程-1"><span class="nav-number">1.2.0.1.</span> <span class="nav-text">基本流程</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#复杂的UDP服务器"><span class="nav-number">1.2.1.</span> <span class="nav-text">复杂的UDP服务器</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#基本流程-2"><span class="nav-number">1.2.1.1.</span> <span class="nav-text">基本流程</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#TCP循环服务器"><span class="nav-number">1.3.</span> <span class="nav-text">TCP循环服务器</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#TCP循环服务器的缺陷"><span class="nav-number">1.3.1.</span> <span class="nav-text">TCP循环服务器的缺陷</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#UDP循环服务器"><span class="nav-number">1.4.</span> <span class="nav-text">UDP循环服务器</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#循环服务器案例与流程分析"><span class="nav-number">1.5.</span> <span class="nav-text">循环服务器案例与流程分析</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#并发服务器-多路复用I-O"><span class="nav-number">1.6.</span> <span class="nav-text">并发服务器:多路复用I/O</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#多路复用I-O处理过程"><span class="nav-number">1.6.1.</span> <span class="nav-text">多路复用I/O处理过程</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#TCP与UDP的对比"><span class="nav-number">1.7.</span> <span class="nav-text">TCP与UDP的对比</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#TCP"><span class="nav-number">1.7.1.</span> <span class="nav-text">TCP</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#滑动窗口协议"><span class="nav-number">1.7.1.1.</span> <span class="nav-text">滑动窗口协议</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#UDP"><span class="nav-number">1.7.2.</span> <span class="nav-text">UDP</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#使用场景"><span class="nav-number">1.7.2.1.</span> <span class="nav-text">使用场景</span></a></li></ol></li></ol></li></ol><li class="nav-item nav-level-2"><a class="nav-link" href="#基础套接口函数的用法与注意事项-例如socket-bind-listen-accept-IO-shut-down-与close的关系-connect"><span class="nav-number">2.</span> <span class="nav-text">基础套接口函数的用法与注意事项 例如socket bind listen accept     IO    shut down 与close的关系   connect</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#shut-down-与close的区别"><span class="nav-number">2.1.</span> <span class="nav-text">shut down 与close的区别</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#bind-分配套接字地址"><span class="nav-number">2.2.</span> <span class="nav-text">bind(分配套接字地址)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#listen-等待连接请求状态"><span class="nav-number">2.3.</span> <span class="nav-text">listen(等待连接请求状态)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#accept-允许连接"><span class="nav-number">2.4.</span> <span class="nav-text">accept(允许连接)</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#基于UDP的数据I-O函数"><span class="nav-number">2.4.1.</span> <span class="nav-text">基于UDP的数据I/O函数</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#UDP的数据传输特性和调用connect函数"><span class="nav-number">2.4.2.</span> <span class="nav-text">UDP的数据传输特性和调用connect函数</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#TCP基本流程"><span class="nav-number">2.4.3.</span> <span class="nav-text">TCP基本流程</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#状态转换表-有些地方要填写-二倍的MSL-作用是什么"><span class="nav-number">3.</span> <span class="nav-text">状态转换表 , 有些地方要填写 二倍的MSL  作用是什么</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#TCP连接队列满了怎么办"><span class="nav-number">4.</span> <span class="nav-text">TCP连接队列满了怎么办</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#listen监听列表满了怎么办"><span class="nav-number">5.</span> <span class="nav-text">listen监听列表满了怎么办</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#UDP-connect与TCP的connect的的区别"><span class="nav-number">6.</span> <span class="nav-text">UDP connect与TCP的connect的的区别</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#多播与广播的特点-优点-缺点-例子-功能-分别用于什么场景-需看得懂代码的作用"><span class="nav-number">7.</span> <span class="nav-text">多播与广播的特点 优点  缺点 例子 功能 分别用于什么场景 需看得懂代码的作用</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#广播"><span class="nav-number">7.1.</span> <span class="nav-text">广播</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#广播优点"><span class="nav-number">7.1.1.</span> <span class="nav-text">广播优点</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#广播缺点"><span class="nav-number">7.1.2.</span> <span class="nav-text">广播缺点</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#广播应用"><span class="nav-number">7.1.3.</span> <span class="nav-text">广播应用</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#多播"><span class="nav-number">7.2.</span> <span class="nav-text">多播</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#多播优点"><span class="nav-number">7.2.1.</span> <span class="nav-text">多播优点</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#多播缺点"><span class="nav-number">7.2.2.</span> <span class="nav-text">多播缺点</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#多播应用"><span class="nav-number">7.2.3.</span> <span class="nav-text">多播应用</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#带外数据-理论-编程实现"><span class="nav-number">8.</span> <span class="nav-text">带外数据 理论 + 编程实现</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#几种方式发送带外数据"><span class="nav-number">8.1.</span> <span class="nav-text">几种方式发送带外数据</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#主要-第一章到第七章"><span class="nav-number">9.</span> <span class="nav-text">主要 第一章到第七章</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#第九章多线程第十章windows编程基本没有"><span class="nav-number">10.</span> <span class="nav-text">第九章多线程第十章windows编程基本没有</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#名词解释4题-20分"><span class="nav-number">11.</span> <span class="nav-text">名词解释4题  20分</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#选择题-10多选-10单选-30分"><span class="nav-number">12.</span> <span class="nav-text">选择题 10多选  10单选  30分</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#问答题4题-20分"><span class="nav-number">13.</span> <span class="nav-text">问答题4题   20分</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#程序阅读题-1题"><span class="nav-number">14.</span> <span class="nav-text">程序阅读题 1题</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#编程题-基本框架-大部分函数原型都在"><span class="nav-number">15.</span> <span class="nav-text">编程题  基本框架  大部分函数原型都在</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#动态分区"><span class="nav-number">16.</span> <span class="nav-text">动态分区</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#主要步骤"><span class="nav-number">16.1.</span> <span class="nav-text">主要步骤</span></a></li></ol></li></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2019</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">R1dd1er</span>

  
</div>


  <div class="powered-by">由 <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a> 强力驱动</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Muse</a> v5.1.4</div>




        
<div class="busuanzi-count">
  <script async src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"></script>

  
    <span class="site-uv">
      <i class="fa fa-user"></i>
      <span class="busuanzi-value" id="busuanzi_value_site_uv"></span>
      
    </span>
  

  
    <span class="site-pv">
      <i class="fa fa-eye"></i>
      <span class="busuanzi-value" id="busuanzi_value_site_pv"></span>
      
    </span>
  
</div>








        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  


  











  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  

  
  
    <script type="text/javascript" src="/lib/canvas-nest/canvas-nest.min.js"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  

  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.4"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.4"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  





  

  

  

  
  

  

  

  

</body>
</html>
